#동전1
#시간제한 0.5초, 메모리제한 4mb -> 최대한 리스트를 적게 생성하는 방향으로 풀이해야 함
#하나의 리스트를 덮어쓰는 방식 + dp를 이용해야 함
#가치의 합이 k원이 되는 경우의 수(전체) -> 가치의 합이 i(<=k)원이 되는 경우의 수 
#->특정 가치를 가진 동전을 썼을 때 가치의 합이 i원이 되는 경우의 수(부분)

n, k=map(int, input().split())
c = [int(input()) for _ in range(n)]
#dp[1]=합이 1원이 되는 경우의 수
dp=[0 for _ in range(k+1)]
#인덱스 0은 동전을 1개만 쓸 떄의 경우의 수를 고려하기 위해 선언
#ex) dp[1], 즉 합이 1인 경우의 수는 1원짜리 동전을 한 개만 쓰는 경우
#dp[1]=dp[1]+dp[0]=0+1 => dp[0]에 할당해놓은 1을 이용해 오류 없이 메모 가능
dp[0]=1 

for i in c:
    for j in range(i, k+1):
        dp[j]+=dp[j-i]
        #dp[3]=(1+1+1)+(1+2) -> 1을 만드는 경우에 2원을 추가 -> dp[3]=dp[1]
        #dp[4]=(1+1+1+1)+(1+1+2)+(2+2) -> 2를 만드는 경우에 2원을 추가  -> dp[4]=dp[2]

print(dp[k])